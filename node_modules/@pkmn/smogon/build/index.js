"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// index.ts
var pkmn_exports = {};
__export(pkmn_exports, {
  Smogon: () => Smogon
});
module.exports = __toCommonJS(pkmn_exports);
var URL = "https://pkmn.github.io/smogon/data/";
var PREFIXES = ["Pichu", "Basculin", "Keldeo", "Genesect", "Vivillon", "Magearna"];
var SUFFIXES = ["-Antique", "-Totem"];
var FORMATS = {
  AG: "anythinggoes",
  Uber: "ubers",
  "(Uber)": "ubers",
  OU: "ou",
  "(OU)": "ou",
  "UUBL": "ou",
  UU: "uu",
  "RUBL": "uu",
  RU: "ru",
  "NUBL": "ru",
  NU: "nu",
  "(NU)": "nu",
  "PUBL": "nu",
  PU: "pu",
  "(PU)": "pu",
  ZU: "zu",
  LC: "lc",
  Unreleased: "anythinggoes",
  Illegal: "anythinggoes",
  CAP: "cap",
  "CAP NFE": "cap",
  "CAP LC": "cap"
};
var BANS = {
  6: ["Groudon-Primal", "Kyogre-Primal"],
  7: ["Groudon-Primal"],
  8: ["Cramorant-Gorging", "Darmanitan-Galar-Zen"]
};
var SPECIAL = /(gen[789](?:vgc20(?:19|21|22|23|24)(reg(?:ulation)?[a-z])?|battlestadium(?:singles|doubles)|bs(?:s|d)))(.*)/;
var TRANSLATE = {
  "gen8bss": "gen8battlestadiumsingles",
  "gen8bsd": "gen8battlestadiumdoubles"
};
var Smogon = class _Smogon {
  constructor(fetch, minimal = false) {
    this.fetch = fetch;
    this.cache = {
      gen: { analyses: {}, sets: {} },
      format: { analyses: {}, sets: {}, stats: {}, teams: {} }
    };
    this.minimal = minimal;
  }
  /**
   * Returns Analysis objects for the given Pokémon species and gen, optionally scoped to a
   * particular format.
   */
  async analyses(gen, species, format) {
    if (typeof species === "string") {
      const s = gen.species.get(species);
      if (!s)
        return [];
      species = s;
    }
    const name = this.name(gen, species);
    const original = format;
    if (format)
      format = this.baseFormat(format);
    const data = {
      analyses: (await this.get("analyses", gen, format))[name],
      sets: (await this.get("sets", gen, format))[name]
    };
    if (!data.analyses || !data.sets)
      return [];
    const result = [];
    for (const tierid in data.analyses) {
      const f = `gen${gen.num}${tierid}`;
      if (format && f !== format)
        continue;
      const a = data.analyses[tierid];
      const s = data.sets[tierid];
      if (!s)
        continue;
      const analysis = {
        format: original || f,
        overview: a.overview,
        comments: a.comments,
        credits: a.credits,
        sets: {}
      };
      let present = false;
      for (const setName in a.sets) {
        const set = s[setName];
        if (set && this.match(species, this.toSet(species, set))) {
          present = true;
          analysis.sets[setName] = __spreadValues({
            description: a.sets[setName].description
          }, set);
        }
      }
      if (present)
        result.push(analysis);
    }
    return result;
  }
  /**
   * Returns PokemonSet objects for the given Pokémon species and gen, optionally scoped to a
   * particular format.
   */
  async sets(gen, species, format) {
    var _a;
    if (typeof species === "string") {
      const s = gen.species.get(species);
      if (!s)
        return [];
      species = s;
    }
    const name = this.name(gen, species);
    if (format)
      format = this.baseFormat(format);
    const data = (await this.get("sets", gen, format))[name];
    if (!data)
      return [];
    const hackmons = (format == null ? void 0 : format.endsWith("balancedhackmons")) && !((_a = BANS[gen.num]) == null ? void 0 : _a.includes(species.name));
    const speciesName = hackmons ? species.name : this.name(gen, species, true);
    const sets = [];
    for (const tierid in data) {
      if (format && `gen${gen.num}${tierid}` !== format)
        continue;
      for (const setName in data[tierid]) {
        const set = this.toSet(species, data[tierid][setName], setName, speciesName);
        if (hackmons || this.match(species, set))
          sets.push(this.fixIVs(gen, set));
      }
    }
    return sets;
  }
  /**
   * Returns weighted moveset usage statistics information for the given Pokémon species and gen for
   * the species' default format or the optional format provided.
   */
  async stats(gen, species, format) {
    if (typeof species === "string") {
      const s = gen.species.get(species);
      if (!s)
        return void 0;
      species = s;
    }
    format = this.baseFormat(format || _Smogon.format(gen, species));
    let stats = this.cache.format.stats[format];
    if (!stats) {
      const response = await this.fetch(`${URL}/stats/${format}.json`);
      stats = this.cache.format.stats[format] = await response.json();
    }
    return stats.pokemon[this.name(gen, species, false, true)];
  }
  /** Returns sample teams for a given format. */
  async teams(format) {
    format = this.baseFormat(format);
    let teams = this.cache.format.teams[format];
    if (!teams) {
      const response = await this.fetch(`${URL}/teams/${format}.json`);
      teams = this.cache.format.teams[format] = await response.json();
    }
    return teams;
  }
  /** Returns the format ID for the 'native' format of a species in the given gen. */
  static format(gen, species) {
    if (typeof species === "string") {
      const s = gen.species.get(species);
      if (!s)
        return void 0;
      species = s;
    }
    const tierid = species.tier === "NFE" ? gen.num < 6 ? "nu" : "pu" : FORMATS[species.tier];
    return `gen${gen.num}${tierid}`;
  }
  // Certain special formats like specific VGC or BSS series get reduced down to a 'base' format.
  baseFormat(format) {
    const m = SPECIAL.exec(format);
    if (!m)
      return format;
    const id = TRANSLATE[m[1]] || m[1];
    return m[2] ? id.slice(0, 11) : id;
  }
  // Fetch analysis or set data for a specific gen and cache the result.
  async get(type, gen, format) {
    let data = this.cache.gen[type][gen.num];
    if (!data) {
      if (this.minimal) {
        if (format) {
          let d = this.cache.format[type][format];
          if (!d) {
            const response = await this.fetch(`${URL}/${type}/${format}.json`);
            d = this.cache.format[type][format] = await response.json();
          }
          const tierid = format.slice(4);
          const result = {};
          for (const species in d)
            result[species] = { [tierid]: d[species] };
          return result;
        } else {
          const result = {};
          for (const f in this.cache.format[type]) {
            const d = this.cache.format[type][f];
            const tierid = f.slice(4);
            for (const species in d) {
              if (result[species]) {
                result[species][tierid] = d[species];
              } else {
                result[species] = { [tierid]: d[species] };
              }
            }
          }
          return result;
        }
      } else {
        const response = await this.fetch(`${URL}/${type}/gen${gen.num}.json`);
        data = this.cache.gen[type][gen.num] = await response.json();
      }
    }
    return data;
  }
  // Returns whether or not the provided set is a match for the forme of the species provided.
  match(species, set) {
    if (species.requiredAbility)
      return set.ability === species.requiredAbility;
    if (species.requiredItem)
      return set.item === species.requiredItem;
    if (species.requiredItems)
      return species.requiredItems.includes(set.item);
    if (species.requiredMove)
      return set.moves.includes(species.requiredMove);
    return true;
  }
  // Returns the name of the species in the provided gen that the data will be keyed as, optionally
  // returning a specific cosmetic forme or the key for stats as opposed to for sets/analyses.
  name(gen, species, specific = false, stats = false) {
    var _a, _b;
    if (species.name === "Greninja-Ash")
      return stats ? species.name : species.baseSpecies;
    if (species.isMega || species.isPrimal || species.name.endsWith("-Crowned")) {
      return species.name;
    }
    if (species.battleOnly) {
      return Array.isArray(species.battleOnly) ? species.battleOnly[0] : species.battleOnly;
    }
    if (species.name.endsWith("-Gmax")) {
      return stats ? species.name : species.baseSpecies;
    }
    if (specific)
      return species.name;
    if (((_b = (_a = gen.species.get(species.baseSpecies)) == null ? void 0 : _a.cosmeticFormes) == null ? void 0 : _b.includes(species.name)) || PREFIXES.some((prefix) => species.name.startsWith(prefix))) {
      return species.baseSpecies;
    }
    const suffixed = stats ? species.name.endsWith("-Antique") : SUFFIXES.some((suffix) => species.name.endsWith(suffix));
    if (suffixed)
      return species.baseSpecies;
    if (species.name.startsWith("Pikachu") && species.name !== "Pikachu-Starter") {
      return species.baseSpecies;
    }
    return species.name;
  }
  // Returns a PokemonSet for the species given a Moveset, optionally named by name and for the
  // specific speciesName (eg. used to set a specific cosmetic forme).
  toSet(species, s, name, speciesName) {
    return {
      name,
      species: speciesName || species.name,
      item: Array.isArray(s.item) ? s.item[0] : s.item,
      ability: Array.isArray(s.ability) ? s.ability[0] : s.ability,
      moves: s.moves.map((ms) => Array.isArray(ms) ? ms[0] : ms),
      level: Array.isArray(s.level) ? s.level[0] : s.level,
      nature: Array.isArray(s.nature) ? s.nature[0] : s.nature,
      ivs: Array.isArray(s.ivs) ? s.ivs[0] : s.ivs,
      evs: Array.isArray(s.evs) ? s.evs[0] : s.evs,
      gigantamax: species.isNonstandard === "Gigantamax",
      teraType: Array.isArray(s.teratypes) ? s.teratypes[0] : s.teratypes
    };
  }
  // Attempt to correct a set's IVs if the Pokémon has Hidden Power and the IVs don't match the
  // required IVs for the given gen or the expected HP DV doesn't match in RBY/GSC.
  fixIVs(gen, set) {
    var _a, _b, _c;
    const hp = set.moves.find((m) => m.startsWith("Hidden Power"));
    if (hp) {
      const type = gen.types.get(hp.slice(13));
      if (type && gen.types.getHiddenPower(gen.stats.fill(__spreadValues({}, set.ivs), 31)).type !== type.name) {
        if (!set.ivs || gen.num >= 7 && (!set.level || set.level === 100)) {
          set.hpType = type.name;
        } else if (gen.num === 2) {
          const ivs = {};
          for (const s in type.HPdvs) {
            const stat = s;
            ivs[stat] = gen.stats.toIV(type.HPdvs[stat]);
            set.ivs[stat] = (_a = set.ivs[stat]) != null ? _a : ivs[stat];
          }
          const actual = gen.types.getHiddenPower(gen.stats.fill(__spreadValues({}, set.ivs), 31));
          if (!(actual.type === type.name && actual.power === 70)) {
            set.ivs = ivs;
          }
        } else {
          for (const s in type.HPivs) {
            const stat = s;
            set.ivs[stat] = (_b = set.ivs[stat]) != null ? _b : type.HPivs[stat];
          }
          const actual = gen.types.getHiddenPower(gen.stats.fill(__spreadValues({}, set.ivs), 31));
          if (!(actual.type === type.name && actual.power === (gen.num < 6 ? 70 : 60))) {
            set.ivs = type.HPivs;
          }
        }
      }
    }
    if (gen.num <= 2 && set.ivs) {
      const expectedHPDV = gen.stats.getHPDV(set.ivs);
      if (expectedHPDV !== gen.stats.toDV((_c = set.ivs.hp) != null ? _c : 31)) {
        set.ivs.hp = gen.stats.toIV(gen.stats.getHPDV(set.ivs));
      }
    }
    return set;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Smogon
});
//# sourceMappingURL=index.js.map