{"version":3,"sources":["../index.ts"],"sourcesContent":["import {\n  AbilityName, Generation, ID, ItemName, MoveName, NatureName,\n  PokemonSet, Specie, StatID, StatsTable, Tier, TypeName,\n} from '@pkmn/data';\n\n// The structure of https://data.pkmn.cc/analyses/genN.json\ninterface GenAnalyses {\n  [species: string]: {\n    [tierid: string]: RawAnalysis;\n  };\n}\n\n// The structure of https://data.pkmn.cc/analyses/genNtier.json\ninterface FormatAnalyses {\n  [species: string]: RawAnalysis;\n}\n\n// The structure of https://data.pkmn.cc/sets/genN.json\ninterface GenSets {\n  [species: string]: {\n    [tierid: string]: {\n      [name: string]: Moveset;\n    };\n  };\n}\n\n// The structure of https://data.pkmn.cc/sets/genNtier.json\ninterface FormatSets {\n  [species: string]: {\n    [name: string]: Moveset;\n  };\n}\n\n// The raw analysis data from https://data.pkmn.cc/ - this needs to be joined with the sets data\n// to form an Analysis which matches what is on Smogon.\ninterface RawAnalysis {\n  outdated?: boolean;\n  overview?: string;\n  comments?: string;\n  sets: { [name: string]: {description?: string; outdated?: boolean}};\n  credits?: Credits;\n}\n\n// Copied from `smogon` package\ninterface Credits {\n  teams: Array<{\n    name: string;\n    members: Member[];\n  }>;\n  writtenBy: Member[];\n}\n\n// Copied from `smogon` package\ninterface Member {\n  user_id: number;\n  username: string;\n}\n\n// The Team datatype from https://data.pkmn.cc/teams/genNtier.json\ninterface Team {\n  name?: string;\n  author?: string;\n  data: PokemonSet[];\n}\n\n/**\n * The reconstituted analysis made from joining a RawAnalysis with the referenced Moveset objects.\n */\nexport interface Analysis extends Omit<RawAnalysis, 'sets'> {\n  format: ID;\n  sets: {[name: string]: Moveset & {description?: string; outdated?: boolean}};\n}\n\n/** A compressed version of the default smogon Moveset type which is smaller to serialize. */\nexport interface Moveset {\n  level?: number | number[];\n  ability: AbilityName | AbilityName[];\n  item?: ItemName | ItemName[];\n  nature?: NatureName | NatureName[];\n  ivs?: Partial<StatsTable> | Partial<StatsTable>[];\n  evs?: Partial<StatsTable> | Partial<StatsTable>[];\n  moves: Array<MoveName | MoveName[]>;\n  teratypes?: TypeName[];\n}\n\n/** A fairly sloppy definition of DeepPartial, but good enough for our use case. */\nexport type DeepPartial<T> = {\n  [P in keyof T]?: T[P] extends Array<infer U>\n    ? Array<DeepPartial<U>>\n    : T[P] extends ReadonlyArray<infer V>\n      ? ReadonlyArray<DeepPartial<V>>\n      : DeepPartial<T[P]>\n};\n\n/** @pkmn/stats output format for statistics. */\nexport interface DisplayStatistics<T = DisplayUsageStatistics> {\n  battles: number;\n  pokemon: { [name: string]: T };\n  metagame: DisplayMetagameStatistics;\n}\n\n/** Output format for legacy smogon.com/stats reports converted to the new @pkmn/stats format. */\nexport interface LegacyDisplayStatistics extends\n  Omit<DisplayStatistics<LegacyDisplayUsageStatistics>, 'metagame'> {\n  metagame?: DisplayMetagameStatistics;\n}\n\n/** @pkmn/stats output format for Pokémon usage statistics. */\nexport interface DisplayUsageStatistics {\n  lead?: Usage;\n  usage: Usage;\n  unique: Usage;\n  win: Usage;\n\n  count: number;\n  weight: number | null;\n  viability: [number, number, number, number];\n\n  abilities: { [name: string]: number };\n  items: { [name: string]: number };\n  stats: { [stats: string]: number };\n  moves: { [name: string]: number };\n  teammates: { [name: string]: number };\n  counters: { [name: string]: [number, number, number] };\n}\n\n/**\n * Output format for the data for a specific Pokémon from legacy smogon.com/stats reports after\n * having been converted to the new @pkmn/stats format.\n */\nexport interface LegacyDisplayUsageStatistics\n  extends Omit<DisplayUsageStatistics, 'unique' | 'win' | 'stats'> {\n  happinesses?: { [happiness: string]: number };\n  spreads: { [spreads: string]: number };\n}\n\n/** @pkmn/stats output format for metagame statistics. */\nexport interface DisplayMetagameStatistics {\n  tags: { [tag: string]: number };\n  stalliness: {\n    histogram: Array<[number, number]>;\n    mean: number;\n    total: number;\n  };\n}\n\n/**\n * Counts of the raw (unweighted), real (unweighted only counting Pokémon that actually appear in\n * battle), and weighted usage for a Pokémon.\n */\nexport interface Usage {\n  raw: number;\n  real: number;\n  weighted: number;\n}\n\nconst URL = 'https://data.pkmn.cc/';\n\nconst PREFIXES = ['Pichu', 'Basculin', 'Keldeo', 'Genesect', 'Vivillon', 'Magearna'];\nconst SUFFIXES = ['-Antique', '-Totem'];\n\n// Conversion between a Pokémon's Tier and a format suffix.\nconst FORMATS: {[key in Exclude<Tier.Singles | 'ZU' | Tier.Other, 'NFE'>]: string} = {\n  AG: 'anythinggoes',\n  Uber: 'ubers', '(Uber)': 'ubers',\n  OU: 'ou', '(OU)': 'ou', 'UUBL': 'ou',\n  UU: 'uu', 'RUBL': 'uu',\n  RU: 'ru', 'NUBL': 'ru',\n  NU: 'nu', '(NU)': 'nu', 'PUBL': 'nu',\n  PU: 'pu', '(PU)': 'pu',\n  ZU: 'zu',\n  LC: 'lc',\n  Unreleased: 'anythinggoes',\n  Illegal: 'anythinggoes',\n  CAP: 'cap', 'CAP NFE': 'cap', 'CAP LC': 'cap',\n};\n\n// Battle-only formes banned in various generations of Balanced Hackmons.\nconst BANS = {\n  6: ['Groudon-Primal', 'Kyogre-Primal'],\n  7: ['Groudon-Primal'],\n  8: ['Cramorant-Gorging', 'Darmanitan-Galar-Zen'],\n};\n\n// eslint-disable-next-line max-len\nconst SPECIAL = /(gen[789](?:vgc20(?:19|21|22|23|24)(reg(?:ulation)?[a-z])?|battlestadium(?:singles|doubles)|bs(?:s|d)))(.*)/;\nconst TRANSLATE = {\n  'gen8bss': 'gen8battlestadiumsingles',\n  'gen8bsd': 'gen8battlestadiumdoubles',\n};\n\n/**\n * Utility class for working with data from Smogon, requires a fetch function to request data. By\n * default this class will fetch an entire generation's worth of data for analyses or sets even if a\n * format parameter is passed to these methods, but if initialized with minimal = true then only a\n * single format will be fetched if a format parameter is provided to the analyses or sets methods.\n * If no format parameter is passed and minimal = true then only data from formats which happen to\n * already be cached will be returned.\n * */\nexport class Smogon {\n  private readonly fetch: (url: string) => Promise<{json(): Promise<any>}>;\n  private readonly cache: {\n    gen: {\n      analyses: {[gen: number]: GenAnalyses};\n      sets: {[gen: number]: GenSets};\n    };\n    format: {\n      analyses: {[formatid: string]: FormatAnalyses};\n      sets: {[formatid: string]: FormatSets};\n      stats: {[formatid: string]: DisplayStatistics | LegacyDisplayStatistics};\n      teams: {[formatid: string]: Team[]};\n    };\n  };\n  private readonly minimal: boolean;\n\n  constructor(fetch: (url: string) => Promise<{json(): Promise<any>}>, minimal = false) {\n    this.fetch = fetch;\n    this.cache = {\n      gen: {analyses: {}, sets: {}},\n      format: {analyses: {}, sets: {}, stats: {}, teams: {}},\n    };\n    this.minimal = minimal;\n  }\n\n  /**\n   * Returns Analysis objects for the given Pokémon species and gen, optionally scoped to a\n   * particular format.\n   */\n  async analyses(gen: Generation, species: string | Specie, format?: ID) {\n    if (typeof species === 'string') {\n      const s = gen.species.get(species);\n      if (!s) return [];\n      species = s;\n    }\n\n    const name = this.name(gen, species);\n    const original = format;\n    if (format) format = this.baseFormat(format);\n    const data = {\n      analyses: (await this.get('analyses', gen, format) as GenAnalyses)[name],\n      sets: (await this.get('sets', gen, format) as GenSets)[name],\n    };\n    if (!data.analyses || !data.sets) return [];\n\n    const result: Analysis[] = [];\n    for (const tierid in data.analyses) {\n      const f = `gen${gen.num}${tierid}` as ID;\n      if (format && f !== format) continue;\n\n      const a = data.analyses[tierid];\n      const s = data.sets[tierid];\n      if (!s) continue;\n\n      const analysis: Analysis = {\n        format: original || f,\n        overview: a.overview,\n        comments: a.comments,\n        credits: a.credits,\n        sets: {},\n      };\n\n      let present = false;\n      for (const setName in a.sets) {\n        const set = s[setName];\n        if (set && this.match(species, this.toSet(species, set))) {\n          present = true;\n          analysis.sets[setName] = {\n            description: a.sets[setName].description,\n            ...set,\n          } as Moveset & {description?: string};\n        }\n      }\n\n      if (present) result.push(analysis);\n    }\n\n    return result;\n  }\n\n  /**\n   * Returns PokemonSet objects for the given Pokémon species and gen, optionally scoped to a\n   * particular format.\n   */\n  async sets(gen: Generation, species: string | Specie, format?: ID) {\n    if (typeof species === 'string') {\n      const s = gen.species.get(species);\n      if (!s) return [];\n      species = s;\n    }\n\n    const name = this.name(gen, species);\n    if (format) format = this.baseFormat(format);\n    const data = (await this.get('sets', gen, format) as GenSets)[name];\n    if (!data) return [];\n\n    // Hackmons allows for various Pokémon to be in their battle-only state.\n    const hackmons =\n      format?.endsWith('balancedhackmons') && !(BANS as any)[gen.num]?.includes(species.name);\n    const speciesName = hackmons ? species.name : this.name(gen, species, true);\n\n    const sets = [];\n    for (const tierid in data) {\n      if (format && `gen${gen.num}${tierid}` !== format) continue;\n      for (const setName in data[tierid]) {\n        const set = this.toSet(species, data[tierid][setName], setName, speciesName);\n        if (hackmons || this.match(species, set)) sets.push(this.fixIVs(gen, set));\n      }\n    }\n\n    return sets;\n  }\n\n  /**\n   * Returns weighted moveset usage statistics information for the given Pokémon species and gen for\n   * the species' default format or the optional format provided.\n   */\n  async stats(\n    gen: Generation, species: string | Specie, format?: ID\n  ) {\n    if (typeof species === 'string') {\n      const s = gen.species.get(species);\n      if (!s) return undefined;\n      species = s;\n    }\n\n    format = this.baseFormat((format || Smogon.format(gen, species))!);\n\n    let stats = this.cache.format.stats[format];\n    if (!stats) {\n      const response = await this.fetch(`${URL}/stats/${format}.json`);\n      stats = this.cache.format.stats[format] = await response.json();\n    }\n\n    return stats.pokemon[this.name(gen, species, false, true)];\n  }\n\n  /** Returns sample teams for a given format. */\n  async teams(format: ID) {\n    format = this.baseFormat(format);\n\n    let teams = this.cache.format.teams[format];\n    if (!teams) {\n      const response = await this.fetch(`${URL}/teams/${format}.json`);\n      teams = this.cache.format.teams[format] = await response.json();\n    }\n\n    return teams;\n  }\n\n  /** Returns the format ID for the 'native' format of a species in the given gen. */\n  static format(gen: Generation, species: string | Specie) {\n    if (typeof species === 'string') {\n      const s = gen.species.get(species);\n      if (!s) return undefined;\n      species = s;\n    }\n    const tierid = species.tier === 'NFE' ? (gen.num < 6 ? 'nu' : 'pu') : FORMATS[species.tier];\n    return `gen${gen.num}${tierid}` as ID;\n  }\n\n  // Certain special formats like specific VGC or BSS series get reduced down to a 'base' format.\n  private baseFormat(format: ID) {\n    const m = SPECIAL.exec(format);\n    if (!m) return format;\n    const id = (TRANSLATE[m[1] as keyof typeof TRANSLATE] || m[1]) as ID;\n    return m[2] ? id.slice(0, 11) as ID : id;\n  }\n\n  // Fetch analysis or set data for a specific gen and cache the result.\n  private async get(type: 'sets' | 'analyses', gen: Generation, format?: ID) {\n    let data = this.cache.gen[type][gen.num];\n    if (!data) {\n      if (this.minimal) {\n        if (format) {\n          let d = this.cache.format[type][format] as any;\n          if (!d) {\n            const response = await this.fetch(`${URL}/${type}/${format}.json`);\n            d = this.cache.format[type][format] = await response.json();\n          }\n          const tierid = format.slice(4);\n          const result: GenAnalyses | GenSets = {};\n          for (const species in d) result[species] = {[tierid]: d[species]};\n          return result;\n        } else {\n          const result: GenAnalyses | GenSets = {};\n          for (const f in this.cache.format[type]) {\n            const d = this.cache.format[type][f] as any;\n            const tierid = f.slice(4);\n            for (const species in d) {\n              if (result[species]) {\n                result[species][tierid] = d[species];\n              } else {\n                result[species] = {[tierid]: d[species]};\n              }\n            }\n          }\n          return result;\n        }\n      } else {\n        const response = await this.fetch(`${URL}/${type}/gen${gen.num}.json`);\n        data = this.cache.gen[type][gen.num] = await response.json();\n      }\n    }\n    return data;\n  }\n\n  // Returns whether or not the provided set is a match for the forme of the species provided.\n  private match(species: Specie, set: DeepPartial<PokemonSet>) {\n    if (species.requiredAbility) return set.ability === species.requiredAbility;\n    if (species.requiredItem) return set.item === species.requiredItem;\n    if (species.requiredItems) return species.requiredItems.includes(set.item as ItemName);\n    if (species.requiredMove) return set.moves!.includes(species.requiredMove);\n    return true;\n  }\n\n  // Returns the name of the species in the provided gen that the data will be keyed as, optionally\n  // returning a specific cosmetic forme or the key for stats as opposed to for sets/analyses.\n  private name(gen: Generation, species: Specie, specific = false, stats = false) {\n    if (species.name === 'Greninja-Ash') return stats ? species.name : species.baseSpecies;\n    if (species.isMega || species.isPrimal || species.name.endsWith('-Crowned')) {\n      return species.name;\n    }\n\n    if (species.battleOnly) {\n      return Array.isArray(species.battleOnly) ? species.battleOnly[0] : species.battleOnly;\n    }\n\n    if (species.name.endsWith('-Gmax')) {\n      return stats ? species.name : species.baseSpecies;\n    }\n\n    if (specific) return species.name;\n\n    if (gen.species.get(species.baseSpecies)?.cosmeticFormes?.includes(species.name) ||\n        PREFIXES.some(prefix => species.name.startsWith(prefix))) {\n      return species.baseSpecies;\n    }\n\n    const suffixed = stats\n      ? species.name.endsWith('-Antique')\n      : SUFFIXES.some(suffix => species.name.endsWith(suffix));\n    if (suffixed) return species.baseSpecies;\n\n    if (species.name.startsWith('Pikachu') && species.name !== 'Pikachu-Starter') {\n      return species.baseSpecies;\n    }\n\n    return species.name;\n  }\n\n  // Returns a PokemonSet for the species given a Moveset, optionally named by name and for the\n  // specific speciesName (eg. used to set a specific cosmetic forme).\n  private toSet(species: Specie, s: Moveset, name?: string, speciesName?: string) {\n    return {\n      name,\n      species: speciesName || species.name,\n      item: Array.isArray(s.item) ? s.item[0] : s.item,\n      ability: Array.isArray(s.ability) ? s.ability[0] : s.ability,\n      moves: s.moves.map(ms => Array.isArray(ms) ? ms[0] : ms),\n      level: Array.isArray(s.level) ? s.level[0] : s.level,\n      nature: Array.isArray(s.nature) ? s.nature[0] : s.nature,\n      ivs: Array.isArray(s.ivs) ? s.ivs[0] : s.ivs,\n      evs: Array.isArray(s.evs) ? s.evs[0] : s.evs,\n      gigantamax: species.isNonstandard === 'Gigantamax',\n      teraType: Array.isArray(s.teratypes) ? s.teratypes[0] : s.teratypes,\n    } as DeepPartial<PokemonSet>;\n  }\n\n  // Attempt to correct a set's IVs if the Pokémon has Hidden Power and the IVs don't match the\n  // required IVs for the given gen or the expected HP DV doesn't match in RBY/GSC.\n  private fixIVs(gen: Generation, set: DeepPartial<PokemonSet>) {\n    const hp = set.moves!.find(m => m.startsWith('Hidden Power'));\n    if (hp) {\n      const type = gen.types.get(hp.slice(13));\n      if (type && gen.types.getHiddenPower(gen.stats.fill({...set.ivs}, 31)).type !== type.name) {\n        if (!set.ivs || (gen.num >= 7 && (!set.level || set.level === 100))) {\n          set.hpType = type.name;\n        } else if (gen.num === 2) {\n          const ivs: Partial<StatsTable> = {};\n          for (const s in type.HPdvs) {\n            const stat = s as StatID;\n            ivs[stat] = gen.stats.toIV(type.HPdvs[stat]!);\n            set.ivs[stat] = set.ivs[stat] ?? ivs[stat];\n          }\n          const actual = gen.types.getHiddenPower(gen.stats.fill({...set.ivs}, 31));\n          if (!(actual.type === type.name && actual.power === 70)) {\n            set.ivs = ivs;\n          }\n        } else {\n          for (const s in type.HPivs) {\n            const stat = s as StatID;\n            set.ivs[stat] = set.ivs[stat] ?? type.HPivs[stat];\n          }\n          const actual = gen.types.getHiddenPower(gen.stats.fill({...set.ivs}, 31));\n          if (!(actual.type === type.name && actual.power === (gen.num < 6 ? 70 : 60))) {\n            set.ivs = type.HPivs;\n          }\n        }\n      }\n    }\n    if (gen.num <= 2 && set.ivs) {\n      const expectedHPDV = gen.stats.getHPDV(set.ivs);\n      if (expectedHPDV !== gen.stats.toDV(set.ivs.hp ?? 31)) {\n        set.ivs.hp = gen.stats.toIV(gen.stats.getHPDV(set.ivs));\n      }\n    }\n    return set;\n  }\n}\n"],"mappings":"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","names":[]}