import { ID, AbilityName, ItemName, NatureName, StatsTable, MoveName, TypeName, Generation, Specie, PokemonSet } from '@pkmn/data';

interface RawAnalysis {
    outdated?: boolean;
    overview?: string;
    comments?: string;
    sets: {
        [name: string]: {
            description?: string;
            outdated?: boolean;
        };
    };
    credits?: Credits;
}
interface Credits {
    teams: Array<{
        name: string;
        members: Member[];
    }>;
    writtenBy: Member[];
}
interface Member {
    user_id: number;
    username: string;
}
interface Team {
    name?: string;
    author?: string;
    data: PokemonSet[];
}
/**
 * The reconstituted analysis made from joining a RawAnalysis with the referenced Moveset objects.
 */
interface Analysis extends Omit<RawAnalysis, 'sets'> {
    format: ID;
    sets: {
        [name: string]: Moveset & {
            description?: string;
            outdated?: boolean;
        };
    };
}
/** A compressed version of the default smogon Moveset type which is smaller to serialize. */
interface Moveset {
    level?: number | number[];
    ability: AbilityName | AbilityName[];
    item?: ItemName | ItemName[];
    nature?: NatureName | NatureName[];
    ivs?: Partial<StatsTable> | Partial<StatsTable>[];
    evs?: Partial<StatsTable> | Partial<StatsTable>[];
    moves: Array<MoveName | MoveName[]>;
    teratypes?: TypeName[];
}
/** A fairly sloppy definition of DeepPartial, but good enough for our use case. */
type DeepPartial<T> = {
    [P in keyof T]?: T[P] extends Array<infer U> ? Array<DeepPartial<U>> : T[P] extends ReadonlyArray<infer V> ? ReadonlyArray<DeepPartial<V>> : DeepPartial<T[P]>;
};
/** @pkmn/stats output format for statistics. */
interface DisplayStatistics<T = DisplayUsageStatistics> {
    battles: number;
    pokemon: {
        [name: string]: T;
    };
    metagame: DisplayMetagameStatistics;
}
/** Output format for legacy smogon.com/stats reports converted to the new @pkmn/stats format. */
interface LegacyDisplayStatistics extends Omit<DisplayStatistics<LegacyDisplayUsageStatistics>, 'metagame'> {
    metagame?: DisplayMetagameStatistics;
}
/** @pkmn/stats output format for Pokémon usage statistics. */
interface DisplayUsageStatistics {
    lead?: Usage;
    usage: Usage;
    unique: Usage;
    win: Usage;
    count: number;
    weight: number | null;
    viability: [number, number, number, number];
    abilities: {
        [name: string]: number;
    };
    items: {
        [name: string]: number;
    };
    stats: {
        [stats: string]: number;
    };
    moves: {
        [name: string]: number;
    };
    teammates: {
        [name: string]: number;
    };
    counters: {
        [name: string]: [number, number, number];
    };
}
/**
 * Output format for the data for a specific Pokémon from legacy smogon.com/stats reports after
 * having been converted to the new @pkmn/stats format.
 */
interface LegacyDisplayUsageStatistics extends Omit<DisplayUsageStatistics, 'unique' | 'win' | 'stats'> {
    happinesses?: {
        [happiness: string]: number;
    };
    spreads: {
        [spreads: string]: number;
    };
}
/** @pkmn/stats output format for metagame statistics. */
interface DisplayMetagameStatistics {
    tags: {
        [tag: string]: number;
    };
    stalliness: {
        histogram: Array<[number, number]>;
        mean: number;
        total: number;
    };
}
/**
 * Counts of the raw (unweighted), real (unweighted only counting Pokémon that actually appear in
 * battle), and weighted usage for a Pokémon.
 */
interface Usage {
    raw: number;
    real: number;
    weighted: number;
}
/**
 * Utility class for working with data from Smogon, requires a fetch function to request data. By
 * default this class will fetch an entire generation's worth of data for analyses or sets even if a
 * format parameter is passed to these methods, but if initialized with minimal = true then only a
 * single format will be fetched if a format parameter is provided to the analyses or sets methods.
 * If no format parameter is passed and minimal = true then only data from formats which happen to
 * already be cached will be returned.
 * */
declare class Smogon {
    private readonly fetch;
    private readonly cache;
    private readonly minimal;
    constructor(fetch: (url: string) => Promise<{
        json(): Promise<any>;
    }>, minimal?: boolean);
    /**
     * Returns Analysis objects for the given Pokémon species and gen, optionally scoped to a
     * particular format.
     */
    analyses(gen: Generation, species: string | Specie, format?: ID): Promise<Analysis[]>;
    /**
     * Returns PokemonSet objects for the given Pokémon species and gen, optionally scoped to a
     * particular format.
     */
    sets(gen: Generation, species: string | Specie, format?: ID): Promise<DeepPartial<PokemonSet<string>>[]>;
    /**
     * Returns weighted moveset usage statistics information for the given Pokémon species and gen for
     * the species' default format or the optional format provided.
     */
    stats(gen: Generation, species: string | Specie, format?: ID): Promise<DisplayUsageStatistics | LegacyDisplayUsageStatistics | undefined>;
    /** Returns sample teams for a given format. */
    teams(format: ID): Promise<Team[]>;
    /** Returns the format ID for the 'native' format of a species in the given gen. */
    static format(gen: Generation, species: string | Specie): ID | undefined;
    private baseFormat;
    private get;
    private match;
    private name;
    private toSet;
    private fixIVs;
}

export { type Analysis, type DeepPartial, type DisplayMetagameStatistics, type DisplayStatistics, type DisplayUsageStatistics, type LegacyDisplayStatistics, type LegacyDisplayUsageStatistics, type Moveset, Smogon, type Usage };
